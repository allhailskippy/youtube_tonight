/**
 * @ngdoc controller
 * @name IndexCtrl
 *
 * @description Controller for the index page of the videos app
 */
(function() {
  "use strict";

var IndexCtrl = function(
  $scope, $window, $routeParams,
  ConnectionHelper, Video, Show, Notice
  ) {
  /**
   * Setup
   */
  $scope.currentVideo = null;

  $scope.page = 1;
  $scope.per_page = 10000;
  $scope.retrieving = true;


  $scope.show = Show.build({});
  $scope.showId = $routeParams.show_id;

  $scope.videos = [];
  $scope.currentVideoOrder = [];

  $scope.dispatcher = ConnectionHelper.getDispatcher();
  $scope.channel = ConnectionHelper.getChannel('video_player');

  // Use new dispatcher because we're unbinding a method later
  $scope.previewDispatch = ConnectionHelper.newDispatcher();
  $scope.previewChannel = ConnectionHelper.newChannel('video_player', $scope.previewDispatch);

  $scope.previewPlayerId = ConnectionHelper.getPlayerId('preview-' + $scope.showId);

  $scope.broadcastId = 'broadcast-' + $scope.showId;
  $scope.previewBroadcastId = $scope.broadcastId + Math.floor(Math.random() * 1000000);
  $scope.broadcastIds = [$scope.broadcastId, $scope.previewBroadcastId];

  $scope.senderIds = {}
  $scope.registeredPlayers = {};

  $scope.state = {};

  // See who's alive
  $scope.dispatcher.trigger('video_player.registered_check', {});

  /**
   * Scope Methods
   */
  $scope.addVideo = function() {
    $scope.currentVideo = Video.build({show: $scope.showId });
    $scope.showForm = true;
  };

  $scope.closeForm = function() {
    $scope.currentVideo = null;
    $scope.showForm = false;
  };

  $scope.editVideo = function(video) {
    $scope.currentVideo = video;
    $scope.showForm = true;
  };

  // Deletes a video from the queue
  $scope.destroy = function(video) {
    if(confirm("Are you sure you want to delete this video from the queue?\nThis cannot be undone.")) {
      video.destroy().then(function() {
        $scope.queryVideos();
      }).catch();
    }
  };

  $scope.broadcastReady = function() {
    return $scope.registeredPlayers[$scope.broadcastId] > 0;
  };

  $scope.isCurrentlyPlaying = function(video) {
    if($scope.state && $scope.state.video) {
      return $scope.state.video.id == video.id;
    } else {
      return false;
    }
  }

  $scope.launchBroadcastPlayer = function() {
    $window.open('/broadcasts#/shows/' + $scope.show.id);
  };

  // Look up list of videos
  $scope.queryVideos = function() {
    if($scope.showId) {
      Show.find($scope.showId).then(function(response) {
        $scope.show = Show.build(response.data);
        var params = {
          page: $scope.page,
          per_page: $scope.per_page,
          show_id: $scope.showId,
          'q[s]': 'sort_order ASC'
        };

        Video.query(params).then(function(response) {
          // If we don't have any videos, then
          // show the new video form
          if(response.data.length == 0) {
            $scope.showForm = true;
          } else {
            $scope.videos = [];
            angular.forEach(response.data, function(video) {
              var newVideo = Video.build(video);
              $scope.videos.push(newVideo);
              $scope.currentVideoOrder.push(newVideo.id);
            });
          }

          $scope.retrieving = false;
        });
      }).catch(Notice.handleErrors);
    }
  };
  // Make actual lookup
  $scope.queryVideos();

  $scope.shouldShowForm = function() {
    return $scope.videos.length == 0 || $scope.showForm;
  }

  // Haw to save sort order
  $scope.sortableOptions = {
    stop: function(e, ui) {
      // this callback has the changed model
      var newVideoOrder = $scope.videos.map(function(o) {
        return o.id;
      });

      if(newVideoOrder.join() != $scope.currentVideoOrder.join()) {
        $scope.videos.map(function(o, i) {
          o.sort_order = i;
          o.save();
        });
      }
    }
  };

  /**
   * Event Handlers
   */

  // Broadcast events
  $scope.playVideo = function(video) {
    angular.forEach($scope.broadcastIds, function(broadcastId) {
      $scope.dispatcher.trigger('video_player.play', {
        video: video,
        player_id: broadcastId,
        sender_id: 'video-' + video.id
      });
    });
  };

  $scope.stopVideo = function(video) {
    $scope.state = {
      playing: false,
      paused: false,
      video: null
    }
    angular.forEach($scope.broadcastIds, function(broadcastId) {
      $scope.dispatcher.trigger('video_player.stop', {
        video: video,
        player_id: broadcastId,
        sender_id: 'video-' + video.id
      });
    });
  };

  $scope.channel.bind('registered', function(message) {
    var count = $scope.registeredPlayers[message.player_id]  || 0;
    $scope.registeredPlayers[message.player_id] = count + 1;
    $scope.$applyAsync()
  });

  $scope.channel.bind('unregistered', function(message) {
    var count = $scope.registeredPlayers[message.player_id] || 0;
    // Don't let count dip < 0
    if(count > 0) {
      $scope.registeredPlayers[message.player_id] = count - 1;
    }

    // Check to see if all our broadcasts have been killed
    if(message.player_id == $scope.broadcastId) {
      if($scope.registeredPlayers[$scope.broadcastId] == 0) {
        $scope.currentlyPlaying = false;
      }
    }
    $scope.$applyAsync()
  });

  // Preview Events
  $scope.channel.bind('playing', function(message) {
    if(message.player_id == $scope.previewPlayerId) {
      $scope.showPreview = true;
      $scope.$applyAsync();
    }
    if(message.player_id == $scope.previewBroadcastId) {
      $scope.state = message.state;
    }
  });

  $scope.channel.bind('stop', function(message) {
    if(message.player_id == $scope.previewPlayerId) {
      $scope.showPreview = false;
      $scope.$applyAsync();
    };
  });

  $scope.channel.bind('stopped', function(message) {
    if(message.player_id == $scope.previewPlayerId) {
      $scope.showPreview = false;
      $scope.$applyAsync();
    };
    if(message.player_id == $scope.previewBroadcastId) {
      $scope.state = message.state;
    }
  });

  //Broadcast init
  // Look up state of the associated player
  $scope.dispatcher.trigger('video_player.get_current_state', {
    player_id: $scope.broadcastId
  });

  // Handle response from requested state
  $scope.previewChannel.bind('current_state', function(message) {
    if(message.player_id == $scope.broadcastId) {
      $scope.state = message;

      if(message.playing) {
        $scope.dispatcher.trigger('video_player.play', {
          player_id: $scope.previewBroadcastId,
          video: message.video
        });
      }
      $scope.previewChannel.unbind('current_state');
    }
  });

  $scope.previewChannel.bind('playing', function(message) {
    if($scope.state.paused) {
      $scope.dispatcher.trigger('video_player.pause', {
        player_id: $scope.previewBroadcastId
      });
    }
    if($scope.state.current_time) {
      $scope.dispatcher.trigger('video_player.set_time', {
        player_id: $scope.previewBroadcastId,
        time: $scope.state.current_time
      });
    }

    // Don't need to listen to this anymore
    $scope.previewChannel.unbind('playing');
  });

  // Other Events
  // Video list changed, need to update
  $scope.channel.bind('update_video_list', function(message) {
    if(message.show_id == $scope.showId) {
      $scope.queryVideos();
    }
  });
};

IndexCtrl.$inject = [
  '$scope', '$window', '$routeParams',
  'ConnectionHelper', 'Video', 'Show', 'Notice'
];

angular.module("VideoApp")
       .controller('IndexCtrl', IndexCtrl);
}());
