/**
 * @ngdoc controller
 * @name VideosIndexCtrl
 *
 * @description Controller for the index page of the videos app
 */
(function() {
  "use strict";

var VideosIndexCtrl = function(
  $scope, $window, $routeParams,
  ConnectionHelper, Video, Show, Notice
  ) {
  /**
   * Setup
   */
  $scope.currentVideo = null;

  $scope.page = 1;
  $scope.per_page = 10000;
  $scope.retrieving = true;

  $scope.show = Show.build({});
  $scope.showId = $routeParams.show_id;

  $scope.videos = [];
  $scope.currentVideoOrder = [];

  $scope.broadcastId = 'broadcast-' + $scope.showId;
  $scope.previewBroadcastId = $scope.broadcastId + Math.floor(Math.random() * 1000000);
  $scope.broadcastConsumer = ConnectionHelper.newConsumer('VideoPlayerChannel', {player_id: $scope.previewBroadcastId, broadcast_id: $scope.broadcastId});

  $scope.previewPlayerId = ConnectionHelper.getPlayerId('preview-' + $scope.showId);
  $scope.previewConsumer = ConnectionHelper.newConsumer('VideoPlayerChannel', {player_id: $scope.previewPlayerId});


//  $scope.broadcastIds = [$scope.broadcastId, $scope.previewBroadcastId];

  $scope.senderIds = {}
  $scope.state = {};
  $scope.broadcastState = {};

  /**
   * Watched variables
   */
  // If the broadcast window is close, but we still have
  // a preview playing, force stop the video
// TODO: Replace this with a more appropriate way to stop the video when out of broadcast windows
//  $scope.$watch('broadcastReady()', function(newVal, oldVal) {
//    if(newVal != oldVal && !newVal) {
//      if($scope.state.video) {
//        $scope.state = {
//          playing: false,
//          paused: false,
//          video: null
//        }
//        $scope.consumer.send({
//          video: $scope.state.video,
//          player_id: $scope.previewBroadcastId
//        }, 'stop');
//      }
//    }
//  });

  /**
   * Scope Methods
   */
  $scope.addVideo = function() {
    $scope.currentVideo = Video.build({show_id: $scope.showId });
    $scope.showForm = true;
  };

  $scope.closeForm = function() {
    $scope.currentVideo = null;
    $scope.showForm = false;
  };

  $scope.editVideo = function(video) {
    if($scope.canManage(video)) {
      $scope.currentVideo = video;
      $scope.showForm = true;
    }
  };

  $scope.canManage = function(video) {
    return ($scope.currentUser.is_admin || video.creator_id == $scope.currentUser.id);
  };

  // Deletes a video from the queue
  $scope.destroy = function(video) {
    if($scope.canManage(video)) {
      if(confirm("Are you sure you want to delete this video from the queue?\nThis cannot be undone.")) {
        video.destroy().then(function() {
          $scope.queryVideos();
        }).catch();
      }
    }
  };

  $scope.launchBroadcastPlayer = function() {
    $window.open('/broadcasts#/shows/' + $scope.show.id);
  };

  // Look up list of videos
  $scope.queryVideos = function() {
    if($scope.showId) {
      Show.find($scope.showId).then(function(response) {
        $scope.show = Show.build(response.data);
        var params = {
          page: $scope.page,
          per_page: $scope.per_page,
          show_id: $scope.showId,
          'q[s]': 'position ASC'
        };

        Video.query(params).then(function(response) {
          // If we don't have any videos, then
          // show the new video form
          if(response.data.length == 0) {
            $scope.showForm = true;
          } else {
            $scope.videos = [];
            angular.forEach(response.data, function(video) {
              var newVideo = Video.build(video);
              $scope.videos.push(newVideo);
              $scope.currentVideoOrder.push(newVideo.id);
            });
          }

          $scope.retrieving = false;
        });
      }).catch(Notice.handleErrors);
    }
  };
  // Make actual lookup
  $scope.queryVideos();

  $scope.shouldShowForm = function() {
    return $scope.videos.length == 0 || $scope.showForm;
  }

  // Haw to save sort order
  $scope.sortableOptions = {
    stop: function(e, ui) {
      // this callback has the changed model
      var newVideoOrder = $scope.videos.map(function(o) {
        return o.id;
      });

      if(newVideoOrder.join() != $scope.currentVideoOrder.join()) {
        $scope.videos.map(function(o, i) {
          o.position = i;
          o.save();
        });
      }
    }
  };

  /**
   * Event Handlers
   */
  // Preview Events
  $scope.doCurrentState = true;
  $scope.doPlaying = true;
  $scope.previewConsumer.subscribe(function(response) {
    var message = response.message;
    switch(response.action) {
      case 'playing':
        if(message.player_id == $scope.previewPlayerId) {
          $scope.showPreview = true;
          $scope.$applyAsync();
        }
        if(message.player_id == $scope.previewBroadcastId) {
          $scope.state = message.state;
        }
        break;
      case 'stop':
        if(message.player_id == $scope.previewPlayerId) {
          $scope.showPreview = false;
          $scope.$applyAsync();
        };
        break;
      case 'stopped':
        if(message.player_id == $scope.previewPlayerId) {
          $scope.showPreview = false;
          $scope.$applyAsync();
        };
        if(message.player_id == $scope.previewBroadcastId) {
          $scope.state = message.state;
        }
        break;
      case 'current_state':
        if($scope.doCurrentState && message.player_id == $scope.broadcastId) {
          $scope.broadcastState = message;

          if(message.playing) {
            $scope.broadcastConsumer.send({
              player_id: $scope.previewBroadcastId,
              video: message.video
            }, 'play');
          }
          $scope.doCurrentState = false;
          // TODO: Figure out why this was unbound
          // $scope.previewChannel.unbind('current_state');
        }
        break;
      case 'playing':
        if($scope.doPlaying) {
          if($scope.broadcastState.paused) {
            $scope.broadcastConsumer.send({ player_id: $scope.previewBroadcastId }, 'pause');
          }
          if($scope.broadcastState.current_time) {
            $scope.broadcastConsumer.send({
              player_id: $scope.previewBroadcastId,
              time: $scope.broadcastState.current_time
            }, 'set_time');
          }
          $scope.doPlaying = false;

          // Don't need to listen to this anymore
         // TODO: Figure out why this is unbound here
         // $scope.previewChannel.unbind('playing');
        }
        break;
      case 'update_video_list':
        // Video list changed, need to update
        if(message.show_id == $scope.showId) {
          $scope.queryVideos();
        }
        break;
    }
  })

  //Broadcast init
  $scope.broadcastReady = function() {
// TODO: Replace this with whatever I decide to do to make this work
//    return ConnectionHelper.broadcastReady($scope.broadcastId);
  };

  $scope.broadcastConsumer.subscribe(function(response) {
    switch(response.action) {
      case '':
        //TODO: Decide if this really needs to be subscribed to
        // or if it can be merged into a single consumer
        break;
    }
  }).then(function() {
    // Look up state of the associated player
    $scope.broadcastConsumer.send({
      player_id: $scope.broadcastId
    }, 'get_current_state');
  });


  // Broadcast events
  $scope.playVideo = function(video) {
    if($scope.broadcastReady()) {
      $scope.broadcastConsumer.send({
        video: video,
        player_id: $scope.previewBroadcastId,
        sender_id: 'video-' + video.id
      }, 'play');
    }
  };

  $scope.stopVideo = function(video) {
    if($scope.broadcastReady()) {
      $scope.state = {
        playing: false,
        paused: false,
        video: null
      }
      $scope.broadcastConsumer.send({
        video: video,
        player_id: $scope.previewBroadcastId,
        sender_id: 'video-' + video.id
      }, 'stop');
    }
  };

};

VideosIndexCtrl.$inject = [
  '$scope', '$window', '$routeParams',
  'ConnectionHelper', 'Video', 'Show', 'Notice'
];

angular.module("YTBroadcastApp")
       .controller('VideosIndexCtrl', VideosIndexCtrl);
}());
