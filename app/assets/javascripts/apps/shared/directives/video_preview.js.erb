/**
 * @ngdoc directive
 * @name VideoPreview
 * @module shared
 *
 * @description
 * This directive displays the video
 *
 * ### Usage
 * <video-preview video="video"></video-preview>
 */
(function() {
'use strict';

var controller = function(
  $scope, $window,
  ConnectionHelper
) {
  /**
   * Setup
   */
  $scope.dispatcher = ConnectionHelper.getDispatcher();
  $scope.channel = $scope.dispatcher.subscribe('video_player');
  $scope.senderId = null;
  $scope.video = null;
  $scope.currentlyPlayingInterval = null;
};

controller.$inject = [
  '$scope', '$window',
  'ConnectionHelper'
];

var VideoPreview = function(
  $window, $interval,
  Video, VideoPreviewService) {
  return {
    restrict: 'E',
    scope: {
      playerId: '@',
      video: '=',
      width: '=',
      height: '=',
      mute: '@'
    },
    controller: controller,
    template: '',
    link: function($scope, $element, $attrs, $controller) {
      /**
       * Setup
       */
      // Initialize the YT iframe api script
      var tag = document.createElement('script');
      tag.src = "https://www.youtube.com/iframe_api";
      var firstScriptTag = document.getElementsByTagName('script')[0];
      firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

      // When the iframe api is loaded,
      $window.onYouTubeIframeAPIReady = function() {
        VideoPreviewService.ready = true;
      };

      /**
       * Scope methods
       */
      // Creates a new YT player object
      $scope.newPlayer = function(preview_elem) {
        var params = {
          videoId: $scope.video.api_video_id,
          width: $scope.width,
          height: $scope.height,
          playerVars: {
            autoplay: 0,
            html5: 1,
            modesbranding: 1,
            iv_load_policy: 3,
            showinfo: 0,
            controls: 0,
            rel: 0,
            start: $scope.video.start_time,
            end: $scope.video.end_time,
            origin: 'http://localhost:3000'
          },
          events: {
            'onReady': function() {
              // Play the video
              $scope.player.playVideo();

              // Start currently playing notice
              $scope.currentlyPlayingInterval = $interval(function() {
                $scope.dispatcher.trigger('video_player.currently_playing', {
                  video: $scope.video,
                  player_id: $scope.playerId,
                  sender_id: $scope.senderId,
                  current_time: $scope.player.getCurrentTime(),
                  duration: $scope.player.getDuration()
                });
              }, 200);
            },
            'onStateChange': function(e) {
              // We're playing!
              if(e.data == YT.PlayerState.PLAYING) {
                // Mute if requested
                if($scope.mute) {
                  e.target.mute();
                };

                $scope.dispatcher.trigger('video_player.playing', {
                  video: $scope.video,
                  player_id: $scope.playerId,
                  sender_id: $scope.senderId
                });
              }

              // We've stopped!
              if(e.data == YT.PlayerState.ENDED) {
                $scope.mute = $scope.mute;
                $scope.dispatcher.trigger('video_player.stop', {
                  video: $scope.video,
                  player_id: $scope.playerId,
                  sender_id: $scope.senderId
                });
              }
            }
          }
        };
        $scope.player = new YT.Player(preview_elem, params);
      };

      /**
       * Event Handlers
       */
      // Restister/unregister this player
      $scope.dispatcher.bind('client_connected', function(message) {
        $scope.dispatcher.trigger('video_player.registered', {
          player_id: $scope.playerId
        });
      });

      $window.onunload = function() {
        $scope.dispatcher.trigger('video_player.unregistered', {
          player_id: $scope.playerId
        });
      };

      $scope.channel.bind('registered_check', function(message) {
        $scope.dispatcher.trigger('video_player.registered', {
          player_id: $scope.playerId
        });
      });


      // Wait for notice to play video
      $scope.channel.bind('play', function(message) {
        if(message.player_id == $scope.playerId) {
          $scope.video = message.video;
          $scope.senderId = message.sender_id;

          // Clear out any existing players
          $element.children().remove();

          // Create the div to hold the video and give it a unique id
          var random_seed = 1 + Math.floor(Math.random() * 100000);
          var preview_id = $scope.video.id + '-' + random_seed;
          var preview = $(
            '<div class="preview_container">' +
            '<div class="preview_overlay"></div>' +
            '<div id="' + preview_id + '"></div></div>'
          );

          var player = $("#" + preview_id, preview);

          // Add new div for player
          $element.append(preview.get());

          VideoPreviewService.waitForReady(function() {
            $scope.newPlayer(player.get(0));
          });
        };
      });

      // Notice to stop a video
      $scope.channel.bind('stop', function(message) {
        if((message.player_id == 'all'
            && $scope.video.id == message.video.id)
          || message.player_id == $scope.playerId) {

          if($scope.player) {
            $scope.player.stopVideo();
          }

          // Clear out player
          $element.children().remove();

          // Stop broadcasting the currently playing video
          $interval.cancel($scope.currentlyPlayingInterval);

          // Notify that we've stopped
          $scope.dispatcher.trigger('video_player.stopped', {
            video: $scope.video,
            player_id: $scope.playerId,
            sender_id: $scope.senderId
          });
        }
      });

      // Mute player
      $scope.channel.bind('mute', function(message) {
        if(message.player_id == $scope.playerId && $scope.player) {
          $scope.mute = true;
          $scope.player.mute();
        }
      });

      // Unmute player
      $scope.channel.bind('unmute', function(message) {
        if(message.player_id == $scope.playerId && $scope.player) {
          $scope.mute = false;
          $scope.player.unMute();
        }
      });

      // Set the player to a specific time
      $scope.channel.bind('set_time', function(message) {
        if(message.player_id == $scope.playerId && $scope.player) {
          $scope.player.seekTo(message.time, true);
        }
      });
    }
  };
};
VideoPreview.$inject = [
  '$window', '$interval',
  'Video', 'VideoPreviewService'
]

// Service for storing shared states
var VideoPreviewService = function() {
  var self = this;

  // Determines if the YT Iframe Api has been loaded
  self.ready = false;

  // Can take a tiny bit before the api is ready
  self.waitForReady = function(callback, delay) {
    delay = delay || 200
    if(!self.ready) {
      setTimeout(self.waitForReady, delay, callback);
    } else {
      callback();
    }
  };
};
VideoPreviewService.$inject = [];

angular.module('shared')
       .service('VideoPreviewService', VideoPreviewService)
       .directive('videoPreview', VideoPreview);
}());
